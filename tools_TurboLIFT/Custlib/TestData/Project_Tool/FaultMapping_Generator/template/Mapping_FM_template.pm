#### This file is generated by the Fault mapping tool ####
#### Can be edited manually! ####

package LIFT_PROJECT;

##########################################################

##########################################################

#Documentation for this mapping file: https://inside-docupedia.bosch.com/confluence/display/aeos/Mapping_Fault
#More detail about Suppression Fault: https://si-airbag-doors-dwa.de.bosch.com:8443/dwa/rm/urn:rational::1-0000000000000000-O-1516-0006b0ff?doors.view=00000007
$Defaults->{'Mapping_FAULT'} = {

	'FAULTMEMORY' => {
		'time_measurements' => 'PD',    #PD (uses Fast Diag) or CD (uses 19 06 to measure the Q/DQ time) !!!! This is only for Quali and Dequali Time measurements and not for fault status check !!!!
	},

	#************************ Expected Fault Status (ISO status bits) under each test condition of the generic Fault list test ************************

	#BIT DESCRIPTION:
	#bit 0 - testFailed (filtered)
	#bit 1 - testFailedThisOperationCycle (latched)
	#bit 2 - pendingDTC
	#bit 3 - confirmedDTC (stored)
	#bit 4 - testNotCompletedSinceLastClear
	#bit 5 - testFailedSinceLastClear
	#bit 6 - testNotCompletedThisOperationCycle
	#bit 7 - warningIndicatorRequested

	#!!!! If any of the above bits are not supported for the project or you don't want to evaluate this bit, set it to x (don't care) !!!!

	#DESCRIPTION of what is done during each of these test steps. Fill in the expected fault status accordingly
	#NO_FAULT 						- before fault creation
	#CREATE_FAULT_CONDITION 		- fault condition is created during steady state
	#RESET_AFTER_FAULT_CREATION 	- fault condition is still active and hard reset is provided
	#CLEAR_AFTER_FAULT_QUALIFIED 	- clear fault memory during steady state
	#RESET_AFTER_FAULT_QUALIFIED	- provide hard reset
	#REMOVE_FAULT_CONDITION			- fault condition is removed during steady state
	#RESET_AFTER_FAULT_REMOVAL		- provide hard reset
	#CLEAR_AFTER_FAULT_REMOVAL		- clear fault memory during steady state

	#!!!! If any of the above steps are not required for the project, set the expected status to SKIP. For example: 'RESET_AFTER_FAULT_CREATION' => 'SKIP', !!!!
	#!!!! CREATE_FAULT_CONDITION and REMOVE_FAULT_CONDITION are mandatory steps and should not be SKIPped !!!!

	'FLT_Status_init' =>    #expected CD fault status for init faults
	  {
		'NO_FAULT'                    => '0bxxxx0000',    #0bxxxx0000
		'CREATE_FAULT_CONDITION'      => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_cyclic' =>                                #expected CD fault status for cyclic faults
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx0',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_init/cyclic' =>                           #expected CD fault status for faults which are handled both during init and steady state
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx0',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_cyclic_DequaliNextPOC' =>                 #expected CD fault status for cyclic faults and faults not dequalify after remove fault condition
	  {                                                   #but these faults dequalify in next POC
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',
	  },

	'FLT_Status_init_permanent' =>                        #expected CD fault status for init faults which do not dequalify
	  {
		'NO_FAULT'                    => '0bxxxx0000',    #0bxxxx0000
		'CREATE_FAULT_CONDITION'      => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx1',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },
	'FLT_Status_init_permanent_QualifyInCylic' =>         #expected CD fault status for init faults which do not dequalify
	  {                                                   #This is a cyclic fault. But as soon as it has qualified, its behaviour will change into the behaviour of init faults for al following POCs Means fault will be re-qualified in init of next POC
		'NO_FAULT'                    => '0bxxxx0000',    #0bxxxx0000
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx1',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_cyclic_permanent' =>                      #expected CD fault status for cyclic faults which do not dequalify
	  {
		'NO_FAULT'                    => '0bxxxx0000',    #0bxxxx0000
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx0000
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx1',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_init_powerstage' =>                       #expected CD fault status for low side power stage and high side power stage faults (Condition shall be created and removed when ECU Off)
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx0',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_init_dequali_cyclic' =>                   #expected CD fault status for faults qualify in init but dequalify in cyclic phase of the same POC
	  {
		'NO_FAULT'                    => '0bxxxx0000',    #0bxxxx0000
		'CREATE_FAULT_CONDITION'      => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx0',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_init_NoClearNoReset' =>                   #expected CD fault status for init faults (no clear and reset between fault creation and removal)
	  {
		'NO_FAULT'                    => '0bxxxx0000',    #0bxxxx0000
		'CREATE_FAULT_CONDITION'      => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	#----------------------- the below types are required for faults which are triggred through SPI manipulation ----------------------

	'FLT_Status_cyclic_SPI' =>                            #expected CD fault status for cyclic SPI faults (no reset between fault creation and removal)
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => 'SKIP',          #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx0',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_init_off' =>                              #expected CD fault status for init  faults (Condition is only created when ECU Off)
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => '0bxxxx0xx0',    #0bxxxx0000
		'RESET_AFTER_FAULT_QUALIFIED' => '0bxxxx1xx1',    #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_init_off_SPI_permanent' =>                #expected CD fault status for init SPI faults which do not dequalify (Condition shall be create when ECU Off)
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx1',    #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },

	'FLT_Status_cyclic_SPI_SingleQuali' =>                #expected CD fault status for cyclic SPI faults which qualify only once (and may trigger Idle mode) (no reset, no clear between fault creation and removal)
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => 'SKIP',          #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',          #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',    #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx1',    #0bxxxx1111
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',    #0bxxxx0000
	  },
	'FLT_Status_cyclic_SPI_SingleQuali_DequaliNextPOC' =>    #expected CD fault status for cyclic SPI faults which qualify only once (and may trigger Idle mode) (no reset, no clear between fault creation and removal)
	  {                                                      #and dequalify in next POC
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',       #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => 'SKIP',             #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',             #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',             #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',       #0bxxxx1111
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx0',       #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',       #0bxxxx0000
	  },

	'FLT_Status_cyclic_SPI_permanent' =>                     #expected CD fault status for cyclic faults (SPI manipulation) which do not dequalify
	  {
		'NO_FAULT'                    => '0bxxxx0000',
		'CREATE_FAULT_CONDITION'      => '0bxxxx1xx1',       #0bxxxx1111
		'RESET_AFTER_FAULT_CREATION'  => '0bxxxx1xx1',       #0bxxxx1111
		'CLEAR_AFTER_FAULT_QUALIFIED' => 'SKIP',             #0bxxxx1111
		'RESET_AFTER_FAULT_QUALIFIED' => 'SKIP',             #0bxxxx1111
		'REMOVE_FAULT_CONDITION'      => '0bxxxx1xx1',       #0bxxxx1110
		'RESET_AFTER_FAULT_REMOVAL'   => '0bxxxx1xx1',       #0bxxxx1100
		'CLEAR_AFTER_FAULT_REMOVAL'   => '0bxxxx0xx0',       #0bxxxx0000
	  },

	#any other project specific fault types with expected fault status can be added here.
	#provide a hash with name FLT_Status_<FaultType> with expected status for each test condition (as in the above cases)

	#+++++++++++++++++++++++++++++++++++++++ FAULT MAPPINGS+++++++++++++++++++++++++++++++++++++++++++++++

#########COPY THE GENERATED FAULT MAPPINGS HERE#######################

};
1;
