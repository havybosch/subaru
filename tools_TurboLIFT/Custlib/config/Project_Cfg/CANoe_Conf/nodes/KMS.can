/*@!Encoding:1252*/
includes
{
  #include "NodeLibrary_KMS.cin"
}

variables
{
  int i;
  int n = 1;
  int stop = 0;
  byte DefaultMasterKey[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xff, 0x8b, 0x75, 0xf7, 0x3e, 0x6a, 0xd5, 0xa1, 0x72, 0x94, 0x23, 0xc6, 0xe9, 0x31, 0x1f, 0x1a, 0x81, 0xb9, 0xf9, 0x69, 0xd4, 0x03, 0x6a, 0x5b, 0x22, 0x1e, 0x76, 0xfa, 0x91, 0x38, 0xae, 0x21, 0xa2, 0xc2, 0xe0, 0x11, 0xdd, 0xc4, 0x27, 0x8f, 0x61, 0xaa, 0xea, 0xcf, 0xb9, 0x6e, 0xaa, 0xd9};
  // byte MasterKeyOnly[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x4d, 0x06, 0xf6, 0xa0, 0x75, 0xbe, 0xbb, 0xca, 0x73, 0x27, 0x3e, 0x69, 0xcf, 0x50, 0x5f, 0x9e, 0x05, 0xb8, 0xb4, 0x0a, 0x45, 0x0f, 0x55, 0xb1, 0x05, 0xfd, 0x40, 0x11, 0x83, 0x5c, 0xde, 0x70, 0x49, 0x4d, 0xe7, 0xe3, 0x27, 0xa1, 0x0f, 0xd1, 0x7f, 0x9c, 0x74, 0x7b, 0x13, 0x81, 0x89, 0xf5};// Wrong cnt count =5
  // HOW TO TEST CASE : ,...
  // uncomment DefaultMasterKey, MasterKeyOnly for corresponding Test case ID:
  //TEST CASE ID 291,303 - Wrong CNT
  //byte DefaultMasterKey[64] ={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x1a, 0xbb, 0xbe, 0xaf, 0xdc, 0x51, 0x35, 0xff, 0x82, 0x0a, 0x08, 0x27, 0x99, 0xa6, 0x1a, 0x09, 0x93, 0xb8, 0x00, 0x43, 0x79, 0xfa, 0xe1, 0x38, 0x37, 0xd6, 0x1f, 0xc9, 0x47, 0x15, 0x05, 0xe0,0xa9, 0xa6, 0xed, 0xdc, 0x4a, 0x5d, 0x64, 0xe2, 0xb6, 0x78, 0x43, 0xaa, 0x3e, 0x83, 0xaa, 0x7e} ; // counter=6, Authkey=Full '0', New Key=Full '1'
//  byte MasterKeyOnly[64]    ={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x4d, 0x06, 0xf6, 0xa0, 0x75, 0xbe, 0xbb, 0xca, 0x73, 0x27, 0x3e, 0x69, 0xcf, 0x50, 0x5f, 0x9e, 0x05, 0xb8, 0xb4, 0x0a, 0x45, 0x0f, 0x55, 0xb1, 0x05, 0xfd, 0x40, 0x11, 0x83, 0x5c, 0xde, 0x70, 0x49, 0x4d, 0xe7, 0xe3, 0x27, 0xa1, 0x0f, 0xd1, 0x7f, 0x9c, 0x74, 0x7b, 0x13, 0x81, 0x89, 0xf5} ;// Wrong cnt count =5, Authkey=Full '1', New Key=Full '0'
  //
   //292, 304 plant pass
 // byte DefaultMasterKey[64] ={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,0xff, 0x8b, 0x75, 0xf7, 0x3e, 0x6a, 0xd5, 0xa1, 0x72, 0x94, 0x23, 0xc6, 0xe9, 0x31, 0x1f, 0x1a, 0x69, 0xcc, 0xff, 0x39, 0x3e, 0x17, 0xba, 0xed, 0xa2, 0x95, 0x24, 0x54, 0xaf, 0x1b, 0x23, 0x11,0x68, 0xd4, 0xae, 0x16, 0xc3, 0x5e, 0x8b, 0x07, 0x3d, 0x03, 0x09, 0x13, 0xed, 0xde, 0x9a, 0x3f}; // counter=1, Authkey=Full '0', New Key=Full '0'
 // byte MasterKeyOnly[64]    ={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x64, 0x4a, 0x4d, 0x75, 0xda, 0xc8, 0x9b, 0x17, 0x11, 0x30, 0x81, 0xe4, 0xbe, 0x5f, 0x97, 0x44,0xd5, 0xf0, 0x1c, 0x44, 0xff, 0xb4, 0xb9, 0x7f, 0x52, 0x98, 0x9d, 0x28, 0x57, 0xa3, 0x33, 0xca,0x8c, 0x06, 0x11, 0xf7, 0x26, 0xea, 0x66, 0x5c, 0x67, 0x8c, 0xdd, 0x44, 0xc2, 0x30, 0x3f, 0xcd} ;// Wrong AuthKey, count =2, Authkey=Full '1', New Key=Full '2'
  //
   //293, 305 plant pass
  //byte DefaultMasterKey[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xff, 0x8b, 0x75, 0xf7, 0x3e, 0x6a, 0xd5, 0xa1, 0x72, 0x94, 0x23, 0xc6, 0xe9, 0x31, 0x1f, 0x1a, 0x81, 0xb9, 0xf9, 0x69, 0xd4, 0x03, 0x6a, 0x5b, 0x22, 0x1e, 0x76, 0xfa, 0x91, 0x38, 0xae, 0x21, 0xa2, 0xc2, 0xe0, 0x11, 0xdd, 0xc4, 0x27, 0x8f, 0x61, 0xaa, 0xea, 0xcf, 0xb9, 0x6e, 0xaa, 0xd9}; // default key
  //byte MasterKeyOnly[64]    ={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41,0xb1, 0x3d, 0x1b, 0x35, 0x9e, 0xce, 0xb5, 0xbc, 0x0c, 0xb3, 0x4e, 0x68, 0xe0, 0xef, 0x03, 0xe6, 0x44, 0x88, 0x78, 0xfc, 0x37, 0x8a, 0xc1, 0x00, 0x51, 0xa6, 0xba, 0x4c, 0x99, 0x54, 0x4d, 0xd2, 0x1b, 0xde, 0x6f, 0xb2, 0xd7, 0x2b, 0x73, 0xd8, 0x13, 0xc3, 0x20, 0xc7, 0xc1, 0xc7, 0x46, 0x3f } ;
  //  
  //294
  //byte DefaultMasterKey[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xff, 0x8b, 0x75, 0xf7, 0x3e, 0x6a, 0xd5, 0xa1, 0x72, 0x94, 0x23, 0xc6, 0xe9, 0x31, 0x1f, 0x1a, 0x81, 0xb9, 0xf9, 0x69, 0xd4, 0x03, 0x6a, 0x5b, 0x22, 0x1e, 0x76, 0xfa, 0x91, 0x38, 0xae, 0x21, 0xa2, 0xc2, 0xe0, 0x11, 0xdd, 0xc4, 0x27, 0x8f, 0x61, 0xaa, 0xea, 0xcf, 0xb9, 0x6e, 0xaa, 0xd9}; // default key
  //byte MasterKeyOnly[64]    ={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41,0x59, 0x11, 0x4c, 0xae, 0xe2, 0x95, 0x51, 0xf1, 0x29, 0x10, 0x3c, 0xe4, 0xdc, 0xd6, 0x7a, 0xa4,0x0d, 0xee, 0x71, 0xca, 0x0e, 0x0d, 0x77, 0x83, 0x6b, 0x51, 0x20, 0xd6, 0xab, 0x38, 0x97, 0x01,0xf7, 0xc6, 0x21, 0xca, 0x4d, 0xc3, 0x41, 0x03, 0xcf, 0x83, 0xec, 0x4e, 0x6c, 0xdd, 0x45, 0x60} ;
  
  //
  //295
 // byte MasterKeyOnly[64]= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xfa, 0x71, 0xb0, 0xe7, 0x4d, 0x91, 0xa4, 0x6f, 0x0d, 0xc8, 0xbb, 0xa0, 0xe5, 0x3b, 0xa2, 0xa2, 0xb2, 0x12, 0x70, 0xaf, 0xe2, 0x9c, 0x81, 0xff, 0x4e, 0x7c, 0xcd, 0x0b, 0x8f, 0x20, 0xf8, 0x09,0xb8, 0x06, 0x62, 0x03, 0xe1, 0x82, 0x5c, 0x60, 0xae, 0x37, 0xed, 0x29, 0x94, 0x9b, 0x8f, 0x30};
  
  //
  //296, 308
   //byte MasterKeyOnly[64]= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x64, 0x4a, 0x4d, 0x75, 0xda, 0xc8, 0x9b, 0x17, 0x11, 0x30, 0x81, 0xe4, 0xbe, 0x5f, 0x97, 0x44, 0x27, 0xd6, 0x54, 0xb8, 0x8d, 0xe9, 0xaa, 0xa5, 0x9e, 0xbb, 0xff, 0xf3, 0x2e, 0xd0, 0x10, 0x70, 0x9e, 0x8c, 0x67, 0x1a, 0x98, 0x4f, 0xeb, 0x26, 0x73, 0xec, 0x3f, 0x5e, 0xa1, 0xf3, 0x95, 0x70};
  //
  //307
 // byte MasterKeyOnly[64]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x99, 0x34, 0x69, 0x32, 0xe0, 0x23, 0xa1, 0xf0, 0xa4, 0xc5, 0x1d, 0x5d, 0x40, 0xbf, 0xdb, 0xfa, 0x4b, 0x1f, 0x5d, 0x5a, 0x67, 0x6d, 0x76, 0x41, 0xe0, 0x7c, 0xc4, 0xab, 0x3d, 0x9f, 0xb3, 0x34, 0x93, 0x79, 0xfa, 0xb2, 0xe6, 0xc5, 0xaa, 0x6d, 0x2c, 0x93, 0xff, 0x86, 0xd6, 0x2b, 0x66, 0xc0};
  //
  //306
  //byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x59, 0x11, 0x4c, 0xae, 0xe2, 0x95, 0x51, 0xf1, 0x29, 0x10, 0x3c, 0xe4, 0xdc, 0xd6, 0x7a, 0xa4, 0xa3, 0x1c, 0x26, 0x54, 0x58, 0x9f, 0x3f, 0x64, 0xc4, 0xbe, 0xe9, 0x0c, 0xfe, 0x8e, 0x6b, 0x34, 0x16, 0xec, 0x5d, 0x0e, 0x6c, 0x5e, 0xcb, 0x72, 0x5d, 0xdf, 0xff, 0x4e, 0x03, 0xae, 0xa4, 0x7c};
  //
  //305
  //byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x64, 0x4a, 0x4d, 0x75, 0xda, 0xc8, 0x9b, 0x17, 0x11, 0x30, 0x81, 0xe4, 0xbe, 0x5f, 0x97, 0x44, 0xd5, 0xf0, 0x1c, 0x44, 0xff, 0xb4, 0xb9, 0x7f, 0x52, 0x98, 0x9d, 0x28, 0x57, 0xa3, 0x33, 0xca, 0xf3, 0x95, 0xa5, 0x92, 0x3a, 0xaf, 0x17, 0x7a, 0xad, 0x3c, 0xdf, 0xb4, 0x00, 0x36, 0xa2, 0x7a};
  //
  //304
 // byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x99, 0x34, 0x69, 0x32, 0xe0, 0x23, 0xa1, 0xf0, 0xa4, 0xc5, 0x1d, 0x5d, 0x40, 0xbf, 0xdb, 0xfa, 0x5f, 0x7d, 0x35, 0x30, 0x4a, 0xfa, 0xf1, 0xad, 0x9b, 0xaa, 0xb6, 0xf0, 0x8f, 0xcb, 0x9c, 0x8f, 0x9d, 0x8c, 0x5e, 0x65, 0xae, 0x09, 0x8f, 0x10, 0x3e, 0x86, 0x87, 0xe1, 0xb1, 0x53, 0xc8, 0xeb};
  //
  //297, 309
   // byte MasterKeyOnly[64]= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51,0x59, 0x11, 0x4c, 0xae, 0xe2, 0x95, 0x51, 0xf1, 0x29, 0x10, 0x3c, 0xe4, 0xdc, 0xd6, 0x7a, 0xa4,0x0d, 0xee, 0x71, 0xca, 0x0e, 0x0d, 0x77, 0x83, 0x6b, 0x51, 0x20, 0xd6, 0xab, 0x38, 0x97, 0x01,0xfe, 0x1e, 0xd5, 0xc0, 0x32, 0x16, 0xdf, 0x4b, 0x0a, 0x59, 0x70, 0x8b, 0x5a, 0x32, 0x34, 0xf0};
  //
  //298
 // byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xca, 0xb7, 0x8f, 0x39, 0x1c, 0xfe, 0x77, 0x46, 0x71, 0x85, 0xe6, 0xc4, 0x4f, 0x86, 0xc4, 0x66, 0xe1, 0x41, 0x65, 0x5d, 0xfe, 0xd9, 0x7d, 0x53, 0x6d, 0xe9, 0xa7, 0x07, 0xbe, 0x75, 0xd8, 0x5a, 0x65, 0x44, 0x5f, 0xb1, 0xcd, 0xfc, 0x44, 0x37, 0x2a, 0x1c, 0xbc, 0x78, 0xb2, 0xfe, 0x1f, 0xb5 };
  //
  //310
  //byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x99, 0x34, 0x69, 0x32, 0xe0, 0x23, 0xa1, 0xf0, 0xa4, 0xc5, 0x1d, 0x5d, 0x40, 0xbf, 0xdb, 0xfa, 0x99, 0x2e, 0xca, 0x08, 0xda, 0x26, 0xbb, 0x5c, 0x5e, 0xa7, 0xa9, 0x5c, 0x64, 0x95, 0x38, 0x31, 0x21, 0xd5, 0x38, 0x5d, 0x54, 0xdf, 0x7f, 0xb6, 0x6e, 0x84, 0x8c, 0x6e, 0xca, 0x9d, 0x4b, 0x0b};
  //
  //299,311
  byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x64, 0x4a, 0x4d, 0x75, 0xda, 0xc8, 0x9b, 0x17, 0x11, 0x30, 0x81, 0xe4, 0xbe, 0x5f, 0x97, 0x44, 0x27, 0xd6, 0x54, 0xb8, 0x8d, 0xe9, 0xaa, 0xa5, 0x9e, 0xbb, 0xff, 0xf3, 0x2e, 0xd0, 0x10, 0x70, 0xf3, 0x7f, 0x95, 0x14, 0x5f, 0x43, 0xe2, 0x3c, 0x05, 0x86, 0x5f, 0x78, 0xa6, 0x6e, 0x13, 0xdd};
  
    //300,312
 // byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x59, 0x11, 0x4c, 0xae, 0xe2, 0x95, 0x51, 0xf1, 0x29, 0x10, 0x3c, 0xe4, 0xdc, 0xd6, 0x7a, 0xa4, 0x0d, 0xee, 0x71, 0xca, 0x0e, 0x0d, 0x77, 0x83, 0x6b, 0x51, 0x20, 0xd6, 0xab, 0x38, 0x97, 0x01, 0xec, 0x16, 0x3c, 0xed, 0x28, 0x5a, 0xd6, 0xc5, 0xa0, 0x61, 0x97, 0x3b, 0xb4, 0x98, 0x55, 0x74};
  //
  
  //301, 313
  //byte MasterKeyOnly[64]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xca, 0xb7, 0x8f, 0x39, 0x1c, 0xfe, 0x77, 0x46, 0x71, 0x85, 0xe6, 0xc4, 0x4f, 0x86, 0xc4, 0x66,  0xe1, 0x41, 0x65, 0x5d, 0xfe, 0xd9, 0x7d, 0x53, 0x6d, 0xe9, 0xa7, 0x07, 0xbe, 0x75, 0xd8, 0x5a,  0x4a, 0xd5, 0x10, 0xc0, 0xaa, 0x6a, 0xfe, 0xf7, 0x6a, 0x97, 0x9f, 0x4f, 0x52, 0x33, 0x75, 0x8e};
  //
  byte DefaultMACKey[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xb7, 0x93, 0x65, 0xde, 0x83, 0xb9, 0xb4, 0x78, 0xbd, 0xf5, 0x28, 0xb0, 0x19, 0x6a, 0x88, 0x71, 0x03, 0x91, 0xcb, 0x95, 0xa1, 0xb9, 0x13, 0x12, 0xe9, 0x9a, 0x03, 0x1a, 0x61, 0x45, 0xb0, 0x04, 0x86, 0xcf, 0x0d, 0x0c, 0x00, 0x53, 0x25, 0x6c, 0x16, 0x25, 0xb3, 0x04, 0x61, 0x03, 0x55, 0x00};
  byte DefaultAESKey[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xca, 0xb7, 0x8f, 0x39, 0x1c, 0xfe, 0x77, 0x46, 0x71, 0x85, 0xe6, 0xc4, 0x4f, 0x86, 0xc4, 0x66, 0x93, 0x8c, 0xf7, 0xb2, 0x60, 0xd9, 0x2a, 0xb3, 0xd4, 0x70, 0xa5, 0x55, 0xf7, 0x75, 0x01, 0x55, 0xaf, 0x1b, 0x91, 0x30, 0x1a, 0x41, 0xfb, 0xec, 0x75, 0xe5, 0x53, 0xe7, 0xae, 0x87, 0x09, 0xd0};
  byte CustomKey[64];
  byte CustomKeyDebug[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xb7, 0x93, 0x65, 0xde, 0x83, 0xb9, 0xb4, 0x78, 0xbd, 0xf5, 0x28, 0xb0, 0x19, 0x6a, 0x88, 0x71, 0x03, 0x91, 0xcb, 0x95, 0xa1, 0xb9, 0x13, 0x12, 0xe9, 0x9a, 0x03, 0x1a, 0x61, 0x45, 0xb0, 0x04, 0x86, 0xcf, 0x0d, 0x0c, 0x00, 0x53, 0x25, 0x6c, 0x16, 0x25, 0xb3, 0x04, 0x61, 0x03, 0x55, 0x00};
  byte CustomKeyDebug1[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xed, 0x1f, 0x5c, 0xfe, 0x93, 0xa5, 0x6f, 0x88, 0x5c, 0x91, 0x5f, 0x8f, 0xbf, 0x98, 0x2d, 0x43, 0xfe, 0x6a, 0x70, 0x7d, 0xb9, 0x3a, 0x14, 0xe8, 0x44, 0xe8, 0xf1, 0xa5, 0x6c, 0x82, 0x77, 0x79, 0x05, 0x5d, 0x6c, 0xbb, 0xe8, 0x5d, 0xda, 0xe1, 0x16, 0xa9, 0xbd, 0x38, 0xaa, 0x54, 0x3a, 0xe0};
  byte CustomVerify[16];
  byte RandomNum[16];
  byte EncryptedNum[32];
  dword EncryptedLengthMAC = 16;
  dword EncryptedLengthAES = 32;
  byte DefaultKeyForVerify[16] = {0x11, 0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};
  byte DefaultInitVector[16] = { 0x8C, 0xCF, 0x74, 0x97, 0x4D, 0x68, 0x72, 0x4F, 0x75, 0x66, 0x0E, 0x16, 0x2D, 0xFA, 0x92, 0xF7 };
  
  msTimer timerWriteMasterOnly;
  msTimer timerWriteAll;
  msTimer timerCustomSingleKey;
  msTimer timerReadSafeKey;
  msTimer timerWritePlant;
  msTimer timerVerifyPlant;
  
  int keyIndex = 0;
  
  message 0x737 Diag_Phys;
  message 0x7DF Diag_Func;
}

on start
{
  MSG_MACKSEND1.Dlc = 8;
  MSG_MACKSEND2.Dlc = 8;
  MSG_MACKSEND3.Dlc = 8;
  MSG_MACKSEND4.Dlc = 8;
  MSG_MACKSEND5.Dlc = 8;
  MSG_MACKSEND6.Dlc = 8;
  MSG_MACKSEND7.Dlc = 8;
  MSG_MACKSEND8.Dlc = 8;
  MSG_MACKVERI1.Dlc = 8;
  MSG_MACKVERI2.Dlc = 8;
  MSG_MACKVERI3.Dlc = 8;
  MSG_MACKVERI4.Dlc = 8;
  MSG_MACKID_MACKUSAGE.Dlc = 8;
  Diag_Phys.dlc = 8;
  Diag_Func.dlc = 8;
}

//on sysvar Security_KMS::Send_Sequence_Message_CGW1S11
//{
//  
//  
//  if (@this == 1)
//  {
//    Diag_Phys.byte(0) = 0x02;
//    Diag_Phys.byte(1) = 0x10;
//    Diag_Phys.byte(2) = 0x03;
//    output(Diag_Phys);
//    Diag_Func.byte(0) = 0x04;
//    Diag_Func.byte(0) = 0x31;
//    Diag_Func.byte(0) = 0x81;
//    Diag_Func.byte(0) = 0x10;
//    Diag_Func.byte(0) = 0x0F;
//    output(Diag_Func);
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND1.byte(i) = @Security_KMS::M1_1[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND2.byte(i) = @Security_KMS::M1_2[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND3.byte(i) = @Security_KMS::M2_1[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND4.byte(i) = @Security_KMS::M2_2[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND5.byte(i) = @Security_KMS::M2_3[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND6.byte(i) = @Security_KMS::M2_4[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND7.byte(i) = @Security_KMS::M3_1[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND8.byte(i) = @Security_KMS::M3_2[i];
//      
//    }
//    
//    setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//    @this = 0;
//  }
//}
//
//on sysvar Security_KMS::Send_Sequence_Message_CGW1S11_2iter
//{
//  if (@this == 1)
//  {
//    Diag_Phys.byte(0) = 0x02;
//    Diag_Phys.byte(1) = 0x10;
//    Diag_Phys.byte(2) = 0x03;
//    output(Diag_Phys);
//    Diag_Func.byte(0) = 0x04;
//    Diag_Func.byte(0) = 0x31;
//    Diag_Func.byte(0) = 0x81;
//    Diag_Func.byte(0) = 0x10;
//    Diag_Func.byte(0) = 0x0F;
//    output(Diag_Func);
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND1.byte(i) = @Security_KMS::M1_1_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND2.byte(i) = @Security_KMS::M1_2_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND3.byte(i) = @Security_KMS::M2_1_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND4.byte(i) = @Security_KMS::M2_2_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND5.byte(i) = @Security_KMS::M2_3_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND6.byte(i) = @Security_KMS::M2_4_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND7.byte(i) = @Security_KMS::M3_1_2iter[i];
//      
//    }
//    for (i=0; i<8; i++) {
//      MSG_MACKSEND8.byte(i) = @Security_KMS::M3_2_2iter[i];
//      
//    }
//    
//    setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//    @this = 0;
//  }
//}
//
//on sysvar Security_KMS::Send_Sequence_Message_CGW1S21
//{
//  if (@this == 1)
//  {
//    Diag_Phys.byte(0) = 0x02;
//    Diag_Phys.byte(1) = 0x10;
//    Diag_Phys.byte(2) = 0x03;
//    output(Diag_Phys);
//    Diag_Func.byte(0) = 0x04;
//    Diag_Func.byte(0) = 0x31;
//    Diag_Func.byte(0) = 0x81;
//    Diag_Func.byte(0) = 0x10;
//    Diag_Func.byte(0) = 0x0F;
//    output(Diag_Func);
//    
//	  MSG_MACKID_MACKUSAGE.MACKUSAGE = @Security_KMS::KeyUsage;
//    MSG_MACKID_MACKUSAGE.MACKID = @Security_KMS::KeyID;
//    for(i=0; i<8; i++) {
//      MSG_MACKVERI1.byte(i) = @Security_KMS::RandomNum_1[i];
//      
//    }
//    for(i=0; i<8; i++) {
//      MSG_MACKVERI2.byte(i) = @Security_KMS::RandomNum_2[i];
//      
//    }
//    for(i=0; i<8; i++) {
//      MSG_MACKVERI3.byte(i) = 0;
//      
//    }
//    for(i=0; i<8; i++) {
//      MSG_MACKVERI4.byte(i) = 0;
//      
//    }
//    setTimer(cyclicTimerVerifyKey, @Security_KMS::CGW1S_Cyclic_time);
//    @this = 0;
//  }
//}
//
//on timer cyclicTimerSetKey
//{
//  switch(n){
//    case(1):
//      output(MSG_MACKSEND1);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 2;
//      break;
//    case(2):
//      output(MSG_MACKSEND2);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 3;
//      break;
//    case(3):
//      output(MSG_MACKSEND3);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 4;
//      break;
//    case(4):
//      output(MSG_MACKSEND4);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 5;
//      break;
//    case(5):
//      output(MSG_MACKSEND5);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 6;
//      break;
//    case(6):
//      output(MSG_MACKSEND6);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 7;
//      break;
//    case(7):
//      output(MSG_MACKSEND7);
//      setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      n = 8;
//      break;
//    case(8):
//      output(MSG_MACKSEND8);
//      n = 1;
//      @Security_KMS::SetNum--;
//      if (@Security_KMS::SetNum > 0) {
//        setTimer(cyclicTimerSetKey, @Security_KMS::CGW1S_Cyclic_time);
//      }
//      break;
//  }
//}
//
//on timer cyclicTimerSetKey_2iter
//{
//  switch(n){
//    case(1):
//      output(MSG_MACKSEND1);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 2;
//      break;
//    case(2):
//      output(MSG_MACKSEND2);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 3;
//      break;
//    case(3):
//      output(MSG_MACKSEND3);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 4;
//      break;
//    case(4):
//      output(MSG_MACKSEND4);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 5;
//      break;
//    case(5):
//      output(MSG_MACKSEND5);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 6;
//      break;
//    case(6):
//      output(MSG_MACKSEND6);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 7;
//      break;
//    case(7):
//      output(MSG_MACKSEND7);
//      setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      n = 8;
//      break;
//    case(8):
//      output(MSG_MACKSEND8);
//      n = 1;
//      @Security_KMS::SetNum_2iter--;
//      if (@Security_KMS::SetNum_2iter > 0) {
//        setTimer(cyclicTimerSetKey_2iter, @Security_KMS::CGW1S_Cyclic_time_2iter);
//      }
//      break;
//  }
//}
//
//on timer cyclicTimerVerifyKey {
//  switch(n) {
//    case(1):
//      output(MSG_MACKID_MACKUSAGE);
//      n = 2;
//      setTimer(cyclicTimerVerifyKey, @Security_KMS::CGW1S_Cyclic_time);
//      break;
//    case(2):
//      output(MSG_MACKVERI1);
//      n = 3;
//      setTimer(cyclicTimerVerifyKey, @Security_KMS::CGW1S_Cyclic_time);
//      break;
//    case(3):
//      output(MSG_MACKVERI2);
//      n = 4;
//      setTimer(cyclicTimerVerifyKey, @Security_KMS::CGW1S_Cyclic_time);
//      break;
//    case(4):
//      output(MSG_MACKVERI3);
//      n = 5;
//      setTimer(cyclicTimerVerifyKey, @Security_KMS::CGW1S_Cyclic_time);
//      break;
//    case(5):
//      output(MSG_MACKVERI4);
//      n = 1;
//      @Security_KMS::SetNum--;
//      if (@Security_KMS::SetNum > 0) {
//        setTimer(cyclicTimerVerifyKey, @Security_KMS::CGW1S_Cyclic_time);
//      }
//      break;
//  }
//}

on sysvar Security_KMS::Button_WriteSingle_DefaultAll
{
  if (@this == 1) {
    Diag_Phys.byte(0) = 0x02;
    Diag_Phys.byte(1) = 0x10;
    Diag_Phys.byte(2) = 0x03;
    output(Diag_Phys);
    n = 0;
    setTimer(timerWriteAll, 20);
  }
}

on timer timerWriteAll
{
  // Send Master Key
  if (n == 0)
  {
    Diag_Phys.byte(0) = 0x10;
    Diag_Phys.byte(1) = 0x44;
    Diag_Phys.byte(2) = 0x31;
    Diag_Phys.byte(3) = 0x81;
    Diag_Phys.byte(4) = 0x10;
    Diag_Phys.byte(5) = 0x10;
    keyIndex = 0;
    for(i = 6; i < 8; i++)
    {
      Diag_Phys.byte(i) = DefaultMasterKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 10);
  }
  else if ((n >= 1) && (n <= 8)) {
    Diag_Phys.byte(0) = 0x20 + n;
    for(i = 1; i < 8; i++)
    {
      Diag_Phys.byte(i) = DefaultMasterKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 5);
  }
  else if (n == 9) {
    Diag_Phys.byte(0) = 0x29;
    for(i = 1; i < 7; i++)
    {
      Diag_Phys.byte(i) = DefaultMasterKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    keyIndex = 0;
    setTimer(timerWriteAll, 1000);
  }
  
  // Send MAC Key
  else if (n == 10)
  {
    Diag_Phys.byte(0) = 0x10;
    Diag_Phys.byte(1) = 0x44;
    Diag_Phys.byte(2) = 0x31;
    Diag_Phys.byte(3) = 0x81;
    Diag_Phys.byte(4) = 0x10;
    Diag_Phys.byte(5) = 0x10;
    keyIndex = 0;
    for(i = 6; i < 8; i++)
    {
      Diag_Phys.byte(i) = DefaultMACKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 10);
  }
  else if ((n >= 11) && (n <= 18)) {
    Diag_Phys.byte(0) = 0x20 + n - 10;
    for(i = 1; i < 8; i++)
    {
      Diag_Phys.byte(i) = DefaultMACKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 5);
  }
  else if (n == 19) {
    Diag_Phys.byte(0) = 0x29;
    for(i = 1; i < 7; i++)
    {
      Diag_Phys.byte(i) = DefaultMACKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    keyIndex = 0;
    setTimer(timerWriteAll, 1000);
  }
  
  //Send AES Key
  else if (n == 20)
  {
    Diag_Phys.byte(0) = 0x10;
    Diag_Phys.byte(1) = 0x44;
    Diag_Phys.byte(2) = 0x31;
    Diag_Phys.byte(3) = 0x81;
    Diag_Phys.byte(4) = 0x10;
    Diag_Phys.byte(5) = 0x10;
    keyIndex = 0;
    for(i = 6; i < 8; i++)
    {
      Diag_Phys.byte(i) = DefaultAESKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 10);
  }
  else if ((n >= 21) && (n <= 28)) {
    Diag_Phys.byte(0) = 0x20 + n - 20;
    for(i = 1; i < 8; i++)
    {
      Diag_Phys.byte(i) = DefaultAESKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 5);
  }
  else if (n == 29) {
    Diag_Phys.byte(0) = 0x29;
    for(i = 1; i < 7; i++)
    {
      Diag_Phys.byte(i) = DefaultAESKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteAll, 5);
    keyIndex = 0;
  }
}

on sysvar Security_KMS::Button_WriteSingle_DefaultMaster
{
  if (@this == 1) {
    write("Start to inject default Master Key");
    Diag_Phys.byte(0) = 0x02;
    Diag_Phys.byte(1) = 0x10;
    Diag_Phys.byte(2) = 0x03;
    output(Diag_Phys);
    n = 0;
    setTimer(timerWriteMasterOnly, 20);
  }
}

on timer timerWriteMasterOnly
{
  // Send Master Key
  if (n == 0)
  {
    Diag_Phys.byte(0) = 0x10;
    Diag_Phys.byte(1) = 0x44;
    Diag_Phys.byte(2) = 0x31;
    Diag_Phys.byte(3) = 0x81;
    Diag_Phys.byte(4) = 0x10;
    Diag_Phys.byte(5) = 0x10;
    
    keyIndex = 0;
    for(i = 6; i < 8; i++)
    {
      Diag_Phys.byte(i) = MasterKeyOnly[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteMasterOnly, 10);
  }
  else if ((n >= 1) && (n <= 8)) {
    Diag_Phys.byte(0) = 0x20 + n;
    for(i = 1; i < 8; i++)
    {
      Diag_Phys.byte(i) = MasterKeyOnly[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteMasterOnly, 1);
  }
  else if (n == 9) {
    Diag_Phys.byte(0) = 0x29;
    for(i = 1; i < 7; i++)
    {
      Diag_Phys.byte(i) = MasterKeyOnly[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerWriteMasterOnly, 10);
  }
  else if (n == 10) {
    Diag_Phys.byte(0) = 0x04;
    Diag_Phys.byte(1) = 0x31;
    Diag_Phys.byte(2) = 0x03;
    Diag_Phys.byte(3) = 0x10;
    Diag_Phys.byte(4) = 0x10;
    Diag_Phys.byte(5) = 0x00;
    Diag_Phys.byte(6) = 0x00;
    Diag_Phys.byte(7) = 0x00;
    output(Diag_Phys);
    keyIndex = 0;
    n=0;
//    if (stop==0) {
//      setTimer(timerWriteMasterOnly, 19);
//      stop = 1;
//    }
//    else {
//      stop = 0;
//    }
  }
}

on sysvar Security_KMS::Button_WriteSingle_CustomKey
{
  long copiedBytes;
  if (@this == 1)
  {
    sysGetVariableData(sysvar::Security_KMS::Array_CustomKey, CustomKey, copiedBytes);
    if (copiedBytes != 64) {
      write("Write customer key: Need to be exact 64 bytes. Dummy array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 64; i++)
      {
        CustomKey[i] = CustomKeyDebug[i];
      }
    }
    Diag_Phys.byte(0) = 0x02;
    Diag_Phys.byte(1) = 0x10;
    Diag_Phys.byte(2) = 0x04;
    output(Diag_Phys);
    n = 0;
    setTimer(timerCustomSingleKey, 20);
  }
}

on timer timerCustomSingleKey
{
  if (n == 0)
  {
    Diag_Phys.byte(0) = 0x10;
    Diag_Phys.byte(1) = 0x44;
    Diag_Phys.byte(2) = 0x31;
    Diag_Phys.byte(3) = 0x81;
    Diag_Phys.byte(4) = 0x10;
    Diag_Phys.byte(5) = 0x10;
    
    keyIndex = 0;
    for(i = 6; i < 8; i++)
    {
      Diag_Phys.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerCustomSingleKey, 10);
  }
  else if ((n >= 1) && (n <= 8)) {
    Diag_Phys.byte(0) = 0x20 + n;
    for(i = 1; i < 8; i++)
    {
      Diag_Phys.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    setTimer(timerCustomSingleKey, 5);
  }
  else if (n == 9) {
    Diag_Phys.byte(0) = 0x29;
    for(i = 1; i < 7; i++)
    {
      Diag_Phys.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    output(Diag_Phys);
    n++;
    keyIndex = 0;
    setTimer(timerCustomSingleKey, 20);
  }
  else if (n == 10) {
    Diag_Phys.byte(0) = 0x04;
    Diag_Phys.byte(1) = 0x31;
    Diag_Phys.byte(2) = 0x03;
    Diag_Phys.byte(3) = 0x10;
    Diag_Phys.byte(4) = 0x10;
    output(Diag_Phys);
    n++;
    setTimer(timerCustomSingleKey, 20);
  }
  else if (n == 11) {
    Diag_Phys.byte(0) = 0x30;
    Diag_Phys.byte(1) = 0x00;
    Diag_Phys.byte(2) = 0x00;
    Diag_Phys.byte(3) = 0x00;
    Diag_Phys.byte(4) = 0x00;
    Diag_Phys.byte(5) = 0x00;
    Diag_Phys.byte(6) = 0x00;
    Diag_Phys.byte(7) = 0x00;
    output(Diag_Phys);
    n++;
    setTimer(timerCustomSingleKey, 1000);
  }
  else if (n == 12) {
    Diag_Phys.byte(0) = 0x04;
    Diag_Phys.byte(1) = 0x31;
    Diag_Phys.byte(2) = 0x03;
    Diag_Phys.byte(3) = 0x10;
    Diag_Phys.byte(4) = 0x10;
    output(Diag_Phys);
    n++;
    setTimer(timerCustomSingleKey, 20);
  }
  else if (n == 13) {
    Diag_Phys.byte(0) = 0x30;
    Diag_Phys.byte(1) = 0x00;
    Diag_Phys.byte(2) = 0x00;
    Diag_Phys.byte(3) = 0x00;
    Diag_Phys.byte(4) = 0x00;
    Diag_Phys.byte(5) = 0x00;
    Diag_Phys.byte(6) = 0x00;
    Diag_Phys.byte(7) = 0x00;
    output(Diag_Phys);
    n = 0;
  }
}

on sysvar Security_KMS::Button_ReadSingle_SafeKeyNumber
{
  if (@this == 1)
  {
    Diag_Phys.byte(0) = 0x03;
    Diag_Phys.byte(1) = 0x22;
    Diag_Phys.byte(2) = 0x01;
    Diag_Phys.byte(3) = 0x0B;
    output(Diag_Phys);
    setTimer(timerReadSafeKey, 50);
  }
}

on timer timerReadSafeKey
{
  Diag_Phys.byte(0) = 0x30;
  Diag_Phys.byte(1) = 0x00;
  Diag_Phys.byte(2) = 0x00;
  Diag_Phys.byte(3) = 0x00;
  Diag_Phys.byte(4) = 0x00;
  Diag_Phys.byte(5) = 0x00;
  Diag_Phys.byte(6) = 0x00;
  Diag_Phys.byte(7) = 0x00;
  output(Diag_Phys);
}

on sysvar Security_KMS::Trigger_WritePlant_TurboLIFT 
{
  long copiedBytes;
  if (@this == 1)
  {
    write("Trigger Write from TurboLIFT");
    sysGetVariableData(sysvar::Security_KMS::Array_CustomKey, CustomKey, copiedBytes);
    if (copiedBytes != 64) {
      write("Write customer key: Need to be exact 64 bytes. Dummy array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 64; i++)
      {
        CustomKey[i] = CustomKeyDebug[i];
      }
    }
    else {
      write("Write key set by tester via sys Var Security_KMS::Array_CustomKey");
    }
    keyIndex = 0;
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND1.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND2.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND3.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND4.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND5.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND6.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND7.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND8.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    keyIndex = 0;
    n = 1;
    setTimer(timerWritePlant, 500);
    @this = 0;
  }
}

on sysvar Security_KMS::Button_WritePlant_MultipleECU
{
  long copiedBytes;
  if (@this == 1)
  {
    sysGetVariableData(sysvar::Security_KMS::Array_CustomKey, CustomKey, copiedBytes);
    if (copiedBytes != 64) {
      write("Write customer key: Need to be exact 64 bytes. Dummy array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 64; i++)
      {
        CustomKey[i] = CustomKeyDebug[i];
      }
    }
    Diag_Phys.byte(0) = 0x02;
    Diag_Phys.byte(1) = 0x10;
    Diag_Phys.byte(2) = 0x03;
    output(Diag_Phys);
    keyIndex = 0;
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND1.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND2.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND3.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND4.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND5.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND6.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND7.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKSEND8.byte(i) = CustomKey[keyIndex];
      keyIndex++;
    }
    keyIndex = 0;
    n = 999;
    setTimer(timerWritePlant, @sysvar::Security_KMS::CGW_Cyclic_time);
  }
}

on timer timerWritePlant
{
  switch(n){
    case(1):
      output(MSG_MACKSEND1);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 2;
      break;
    case(2):
      output(MSG_MACKSEND2);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 3;
      break;
    case(3):
      output(MSG_MACKSEND3);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 4;
      break;
    case(4):
      output(MSG_MACKSEND4);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 5;
      break;
    case(5):
      output(MSG_MACKSEND5);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 6;
      break;
    case(6):
      output(MSG_MACKSEND6);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 7;
      break;
    case(7):
      output(MSG_MACKSEND7);
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      n = 8;
      break;
    case(8):
      output(MSG_MACKSEND8);
      n = 1;
      @Security_KMS::SetNum--;
      if (@Security_KMS::SetNum > 0) {
        setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      }
      break;
    case(999):
      Diag_Func.byte(0) = 0x04;
      Diag_Func.byte(1) = 0x31;
      Diag_Func.byte(2) = 0x81;
      Diag_Func.byte(3) = 0x10;
      Diag_Func.byte(4) = 0x0E;
      output(Diag_Func);
      n = 1;
      setTimer(timerWritePlant, @Security_KMS::CGW_Cyclic_time);
      break;
  }
}

on sysvar Security_KMS::Trigger_VeriPlant_TurboLIFT
{
  int result;
  long copiedBytes;
  byte KeyForVerification[16];
  
  if (@this == 1)
  {
    write("Trigger verification from TurboLIFT");
    sysGetVariableData(sysvar::Security_KMS::Array_RandomNum, RandomNum, copiedBytes);
    if (copiedBytes != 16) {
      write("Random number: Need to be exact 16 bytes. Dummy array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 16; i++)
      {
        RandomNum[i] = i;
      }
    }
    sysGetVariableData(sysvar::Security_KMS::Array_CustomKeyForVerification, CustomVerify, copiedBytes);
    if (copiedBytes != 16) {
      write("Verify key: Need to be exact 16 bytes. Default array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 16; i++)
      {
        KeyForVerification[i] = DefaultKeyForVerify[i];
      }
    }
    else{
      write("Use custom key to verify set by tester via sys var Array_CustomKeyForVerification");
      for (i = 0; i < 16; i++)
      {
        KeyForVerification[i] = CustomVerify[i];
      }
    }
    keyIndex = 0;
	  MSG_MACKID_MACKUSAGE.MACKUSAGE = @Security_KMS::KeyUsage;
    MSG_MACKID_MACKUSAGE.MACKID = @Security_KMS::KeyID;
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI1.byte(i) = RandomNum[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI2.byte(i) = RandomNum[keyIndex];
      keyIndex++;
    }
    //TODO: Handle MAC/AES calculate here
    if(@Security_KMS::KeyUsage == 1)
    {
      //Calculating MAC
      write("CMAC calculated for verification process");
      result = LocalSecurityGenerateCMAC(KeyForVerification, 16, RandomNum, 16, EncryptedNum, EncryptedLengthMAC);
      write("Calculation CMAC result: %i", result);
    }
    else if (@Security_KMS::KeyUsage == 0)
    {
      //Calculating AES
      write("AES calculated for verification process");
      result = LocalSecurityEncryptAES128CBC(KeyForVerification, 16, RandomNum, 16, DefaultInitVector, 16, EncryptedNum, EncryptedLengthAES);
      write("Calculation AES result: %i", result);
    }
    
    keyIndex = 0;
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI3.byte(i) = EncryptedNum[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI4.byte(i) = EncryptedNum[keyIndex];
      keyIndex++;
    }
    
    keyIndex = 0;
    n = 1;
    setTimer(timerVerifyPlant, 500);
    @this = 0;
  }
}

on sysvar Security_KMS::Button_VerifyPlant_MultipleECU
{
  int result;
  long copiedBytes;
  byte KeyForVerification[16];
  if (@this == 1)
  {
    sysGetVariableData(sysvar::Security_KMS::Array_RandomNum, RandomNum, copiedBytes);
    if (copiedBytes != 16) {
      write("Random number: Need to be exact 16 bytes. Dummy array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 16; i++)
      {
        RandomNum[i] = i;
      }
    }
    sysGetVariableData(sysvar::Security_KMS::Array_CustomKeyForVerification, CustomVerify, copiedBytes);
    if (copiedBytes != 16) {
      write("Verify key: Need to be exact 16 bytes. Default array will be used instead (for DEBUG ONLY)");
      for (i = 0; i < 16; i++)
      {
        KeyForVerification[i] = DefaultKeyForVerify[i];
      }
    }
    else{
      write("Use custom key to verify");
      for (i = 0; i < 16; i++)
      {
        KeyForVerification[i] = CustomVerify[i];
      }
    }
    Diag_Phys.byte(0) = 0x02;
    Diag_Phys.byte(1) = 0x10;
    Diag_Phys.byte(2) = 0x03;
    output(Diag_Phys);
    keyIndex = 0;
	  MSG_MACKID_MACKUSAGE.MACKUSAGE = @Security_KMS::KeyUsage;
    MSG_MACKID_MACKUSAGE.MACKID = @Security_KMS::KeyID;
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI1.byte(i) = RandomNum[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI2.byte(i) = RandomNum[keyIndex];
      keyIndex++;
    }
    //TODO: Handle MAC/AES calculate here
    if(@Security_KMS::KeyUsage == 1)
    {
      //Calculating MAC
      write("CMAC calculated for verification process");
      result = LocalSecurityGenerateCMAC(KeyForVerification, 16, RandomNum, 16, EncryptedNum, EncryptedLengthMAC);
      write("Calculation CMAC result: %i", result);
    }
    else if (@Security_KMS::KeyUsage == 0)
    {
      //Calculating AES
      write("AES calculated for verification process");
      result = LocalSecurityEncryptAES128CBC(KeyForVerification, 16, RandomNum, 16, DefaultInitVector, 16, EncryptedNum, EncryptedLengthAES);
      write("Calculation AES result: %i", result);
    }
    
    keyIndex = 0;
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI3.byte(i) = EncryptedNum[keyIndex];
      keyIndex++;
    }
    for (i = 0; i < 8; i++)
    {
      MSG_MACKVERI4.byte(i) = EncryptedNum[keyIndex];
      keyIndex++;
    }
    
    keyIndex = 0;
    n = 999;
    setTimer(timerVerifyPlant, @sysvar::Security_KMS::CGW_Cyclic_time);
    
  }
}

on timer timerVerifyPlant {
  switch(n) {
    case(1):
      output(MSG_MACKID_MACKUSAGE);
      n = 2;
      setTimer(timerVerifyPlant, @Security_KMS::CGW_Cyclic_time);
      break;
    case(2):
      output(MSG_MACKVERI1);
      n = 3;
      setTimer(timerVerifyPlant, @Security_KMS::CGW_Cyclic_time);
      break;
    case(3):
      output(MSG_MACKVERI2);
      n = 4;
      setTimer(timerVerifyPlant, @Security_KMS::CGW_Cyclic_time);
      break;
    case(4):
      output(MSG_MACKVERI3);
      n = 5;
      setTimer(timerVerifyPlant, @Security_KMS::CGW_Cyclic_time);
      break;
    case(5):
      output(MSG_MACKVERI4);
      n = 1;
      @Security_KMS::SetNum--;
      if (@Security_KMS::SetNum > 0) {
        setTimer(timerVerifyPlant, @Security_KMS::CGW_Cyclic_time);
      }
      break;
    case(999):
      Diag_Func.byte(0) = 0x04;
      Diag_Func.byte(1) = 0x31;
      Diag_Func.byte(2) = 0x81;
      Diag_Func.byte(3) = 0x10;
      Diag_Func.byte(4) = 0x0F;
      output(Diag_Func);
      n = 1;
      setTimer(timerVerifyPlant, @Security_KMS::CGW_Cyclic_time);
      break;
  }
}

//on key 'q'
//{
//  long copiedBytes;
//  if (1)
//  {
//    sysGetVariableData(sysvar::Security_KMS::Array_CustomKey, CustomKey, copiedBytes);
//    if (copiedBytes != 64) {
//      write("Write customer key: Need to be exact 64 bytes. Dummy array will be used instead (for DEBUG ONLY)");
//      for (i = 0; i < 64; i++)
//      {
//        CustomKey[i] = CustomKeyDebug1[i];
//      }
//    }
//    Diag_Phys.byte(0) = 0x02;
//    Diag_Phys.byte(1) = 0x10;
//    Diag_Phys.byte(2) = 0x03;
//    output(Diag_Phys);
//    keyIndex = 0;
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND1.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND2.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND3.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND4.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND5.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND6.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND7.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    for (i = 0; i < 8; i++)
//    {
//      MSG_MACKSEND8.byte(i) = CustomKey[keyIndex];
//      keyIndex++;
//    }
//    keyIndex = 0;
//    n = 999;
//    setTimer(timerWritePlant, @sysvar::Security_KMS::CGW_Cyclic_time);
//  }
//}